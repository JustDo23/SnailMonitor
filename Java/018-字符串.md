## 018-字符串

![JavaSE.png](https://raw.githubusercontent.com/JustDo23/SnailMonitor/master/Picture/Cover/JavaSE.png)

> 引言： Java Platform, Standard Edition.
>
> 作者：JustDo23
>
> 时间：2022年09月21日
>
> 官网：[https://www.oracle.com](https://www.oracle.com)

### 01. 类 String

1. **官方文档**

   * 首先，String 类代表 **`字符串`** 。
   * 其次，Java 程序中的所有字符串 **`字面值`** 都作为此类的 **`实例`** 实现。
   * 再者，字符串是 **`常量`** ；它们的值在创建之后 **`不能更改`** ；因此可以 **`共享`** 。
   * 另外，字符串 **`缓冲区`** 支持 **`可变`** 的字符串。

2. **简单源码**

   ```java
   package java.lang;
   
   public final class String
       implements java.io.Serializable, Comparable<String>, CharSequence {
     
       public String toString() {
           return this;
       }
   
       public boolean equals(Object anObject) {
           if (this == anObject) {
               return true;
           }
           if (anObject instanceof String) {
               String anotherString = (String) anObject;
               int n = length();
               if (n == anotherString.length()) {
                   int i = 0;
                   while (n-- != 0) {
                       if (charAt(i) != anotherString.charAt(i))
                           return false;
                       i++;
                   }
                   return true;
               }
           }
           return false;
       }
   
   }
   ```

   * 所在的包路径为 **`java.lang.String`** 
   * 类名被 **`final`** 修改表示为最终类
   * 实现了 **`Serializable`** 序列化 **`Comparable`** 比较 **`CharSequence`**  字符序列
   * 重写 **`equals()`** 函数以实现内容对比

3. **代码尝试**

   ```java
   public static void main(String[] args) {
       String s1 = "Just"; // 创建并放入常量池
       String s2 = "Just"; // 直接复用共享常量池
       System.out.println(s1 == s2); // true 引用地址相同
       String s3 = "Do"; // 创建并放入常量池
       String s4 = new String("Do"); // 常量池中对象作为参数
       // 使用 new 开辟新的内存空间
       System.out.println(s3 == s4); // false 引用地址不同
       System.out.println(s3.equals(s4)); // true 存储内容相同
       char data[] = {'a', 'b', 'c'}; // 字符数组
       String s6 = new String(data); // 构造传参
   }
   ```

4. **小结一下**

   * 字符串都是对象
   * 初始化后不能被更改
   * 构造函数可以传递多种类型数据

### 02. 常用方法

1. **代码示例**

   ```java
   public static void main(String[] args) {
       String str = "JustDoIt."; // 实例
       int length = str.length(); // 求长度
       int firstIndex = str.indexOf('t'); // 查找位置，首次出现
       int lastIndex = str.lastIndexOf('t'); // 查找位置，最后一次出现
       char target = str.charAt(3); // 获取指定位置的字符
       String sub = str.substring(2, 5); // 获取子串，包含头，不包含尾。
       boolean isStart = str.startsWith("Do"); // 是否以参数为开头
       boolean isEnd = str.endsWith("It"); // 是否以参数为结尾
       boolean isHas = str.contains("us"); // 是否包含指定字符串
       String result = str.replace("It", "23"); // 字符串替换
       char[] chars = str.toCharArray(); // 获取字符数组
       byte[] bytes = str.getBytes(); // 获取字节数组
       String up = str.toUpperCase(); // 全部转为大写
       String low = str.toLowerCase(); // 全部转为小写
       String[] array = str.split(","); // 按指定字符切割
       int compare = str.compareTo("23"); // 比较大小
   }
   ```

2. **比较大小**

   * 使用 **`compareTo()`** 方法按 **`字典顺序`** 比较两个字符串。
   * 该比较基于字符串中各个字符的 **`Unicode`** 值。
   * 按字典顺序将此 String 对象表示的 **`字符序列`** 与参数字符所表示的字符序列进行比较。
   * 两者按字符序列从头开始逐一比较，找到第一个字符不同的索引位置，返回这两个字符串在该索引位置的两个字符的差值。
   * 如果没有字符不同的索引位置，则 **`较短`** 字符串的字典顺序在 **`较长`** 字符串之前，此时返回两者长度的差值。
   * 返回 **`等于0`** 表示：此字符串 **`等于`** 参数字符串
   * 返回 **`小于0`** 表示：此字符串 **`小于`** 参数字符串
   * 返回 **`大于0`** 表示：此字符串 **`大于`** 参数字符串

3. **代码实践**

   ```java
   public static void main(String[] args) {
       System.out.println("bc".compareTo("bc")); // 0
       System.out.println("bc".compareTo("ba")); // 大于 0
       System.out.println("bc".compareTo("bf")); // 小于 0
       System.out.println("bc".compareTo("ax")); // 大于 0
       System.out.println("bc".compareTo("bcd")); // 小于 0
   }
   ```
   
3. **重点注意**

   * 一个对象的方法必然是围绕着操作这个对象的数据而定义的。
   * 学会查询 API 文档，学会查找自己需要的函数。

### 03. 比较 Comparable

1. **简单介绍**

   此接口强行对实现它的每个类的对象进行整体排序。这种排序称为类的自然排序。实现接口并重写比较方法，以实现对象的间的比较。

2. **简单示例**

   ```java
   public class Student implements Comparable<Student> {
   
       private int score; // 分数
   
       @Override
       public int compareTo(Student another) {
           return this.score - another.score;
       }
   
   }
   ```

### 04. 类 StringBuffer

1. **字符串缓冲区**

   * 线程 **`安全`** 的 **`可变`** 字符序列。
   * 一个类似于 String 的字符缓冲区，引用地址不能修改，但可以修改其内部字符序列的长度和内容。
   * 每个字符串缓冲区都有一定的 **`容量`** 。只要字符串缓冲区所包含的字符序列长度没有超出此容量，就无需分配新的内部缓冲区 **`数组`** 。如果内部缓冲区溢出，则自动 **`扩容`** 。

2. **简单总结**

   * 字符串缓冲区，其实就是一个 **`容器`** 。
   * 长度是 **`可变`** 的。
   * 可以添加 **`任意`** 类型数据，但都是转成 **`字符串`** 进行存储。
   * 该 **`容器`** 对象提供了很多对容器中数据进行操作的功能。
   * 最终所有的数据转变成一个字符串。

3. **起始容量**

   * 无参构造函数会构造一个其中不带任何字符的字符串缓冲区，其初始容量为 **`16 个字符`** 。

4. **代码示例**

   ```java
   public static void main4(String[] args) {
       StringBuffer sb = new StringBuffer();
       sb.append("Learn").append(" ").append("Java");
       sb.insert(5, true);
       sb.insert(5, " $- ");
       sb.delete(6, 7); // 包含头不包含尾
       sb.replace(6, 12, "Oracle"); // 包含头不包含尾
       sb.reverse(); // 反转
   }
   ```

5. **操作符 + 号**

   * Java 语言提供对字符串串联符号 **`+`** 以及将其他对象转换为字符串的特殊支持。
   * 字符串串联是通过 **`StringBuilder`** 或 **`StringBuffer`** 实现的。

   ```java
   public static void main4(String[] args) {
       String result = "Just" + " do " + "it.";
       // 等价于
       StringBuffer like = new StringBuffer();
       like.append("Just").append(" do ").append("it.");
   }
   ```

### 05. 类 StringBuilder

1. **简单概述**
   * 一个可变的字符序列。但不保证同步。
   * **`线程不安全的`** 。单线程中使用，效率比较高。

