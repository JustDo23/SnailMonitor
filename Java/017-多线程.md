## 017-多线程

![JavaSE.png](https://raw.githubusercontent.com/JustDo23/SnailMonitor/master/Picture/Cover/JavaSE.png)

> 引言： Java Platform, Standard Edition.
>
> 作者：JustDo23
>
> 时间：2022年09月15日
>
> 官网：[https://www.oracle.com](https://www.oracle.com)

### 14. 方法对比

1. **两个函数**：
    * **`sleep`**
    * **`wait`**
    
2. **相同点**：
    * 都可以让线程处于冻结状态。
    
3. **不同点**：

    * **`sleep`** 必须指定时间；**`wait`** 可以指定时间，也可以不指定时间。
    * **`sleep`** 时间到，线程处于临时阻塞或者运行状态；**`wait`** 如果没有时间，必须要通过 **`notify()`** 或者 **`notifyAll()`** 来唤醒。
    * **`sleep`** 不一定非要定义在同步中；**`wait`** 必须定义在同步中。
    * 若两者都定义在同步中时，线程执行到 **`sleep`** 后不会释放锁；线程执行到 **`wait`** 后会释放锁。

**注意**：在同步中当执行到 **`notify()`** 或者 **`notifyAll()`** 后会从线程池中去唤醒正在等待的线程，而刚被唤醒的线程有可能会因为主动唤醒方还没有释放同步锁而处于临时阻塞状态，直到主动唤醒方释放同步锁后才会有可能被执行。

### 15. 线程的停止

1. **stop()**

    * 着重强调：这个方法已经 **`过时`** 了，该方法具有固有的 **`不安全`** 性。
    * 线程结束：其实就是让线程任务代码执行完，也就是 **`run()`** 方法运行结束。
    * 替换方案：该方法应由只修改某些变量以指示目标线程应该停止运行的代码来取代。
    * 实际操作：添加一个控制变量，目标线程应定期检查该变量，并且如果该变量指示它要停止运行，则从其运行方法依次返回。
    * 特殊情况：如果目标线程等待很长时间，例如线程处于了冻结状态，则应使用 `interrupt()` 方法来中断该等待。

3. **interrupt()**

    * 中断线程。并不是将线程进行停止。
    * 主要功能是将线程的冻结状态清除，让线程恢复到运行状态，也就是让线程重新CPU的运行资格。
    * 因为是强制清除，所以会发生异常，可以在 `catch` 中进行异常捕获。在异常处理中，改变控制变量，让线程运行结束。
    * 线程调用 `wait()` `join()` `sleep()` 方法后处于冻结状态；线程调用 `interrupt()` 方法后其中断状态将被清除，还将收到一个 `InterruptedException` 异常。

    ```java
    public synchronized void simple() {
        while (flag) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
                flag = false;
            }
        }
    }
    ```

### 16. 守护线程

1. **简单概述**

    守护线程：后台线程。

    前台线程：一般创建的线程都是前台线程。

2. **相同点**

    * 前台后台线程运行时都是一样的，获取CPU的执行权进行执行。
    * 前台后台线程 `run()` 方法运行结束，则线程也会跟着结束。

3. **不同点**

    * 当进程中所有的前台线程都结束了，后台线程也会跟着结束，从而进程结束。
    * 进程结束依赖的都是前台线程。

4. **设置方法**

    **`setDaemon(boolean on)`** 将线程标记为守护线程或者用户线程。

    当正在运行的线程都是守护线程时，Java 虚拟机退出。

### 17. 线程优先级

1. **简单概述**

    每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护线程。当某个线程中运行的代码创建一个新的 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护线程。

2. **优先级**

    * 用数字进行标识，范围为 1 到 10
    * 默认的初始优先级为 5

3. **设置方法**

    **`setPriority(int newPriority)`** 更改线程的优先级。

    * 常量 `Thread.MAX_PRIORITY` 最高优先级
    * 常量 `Thread.NORM_PRIORITY` 默认优先级
    * 常量 `Thread.MIN_PRIORITY` 最低优先级

### 18. 线程组

1. **简单概述**

    **`ThreadGroup`** 线程组表示一个线程的集合。此外，线程组也可以包含其他线程组。线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组。

    允许线程访问有关自己的线程组信息，但是不允许它访问有关其线程组的父线程组或其他任何线程组的信息。

2. **其它介绍**

    * 所有线程默认启动起来都是属于主线程组的。
    * 可以通过 `Thread` 类的构造函数明确新线程对象所属的线程组。
    * 好处是可以对多个同组线程进行统一的操作。

### 19. 多线程小细节

1. **`join()`**

    * 等待该线程终止。
    * 当前线程执行到其他线程调用 `join()` 方法后，就知道其他线程需要加入执行，当前线程就会释放 CPU 的执行权和执行资格，并处于冻结状态，等待其他线程执行结束后才会进行恢复。

2. **`yield()`**

    * 暂停当前正在执行的线程对象，并执行其他线程。
    * 线程临时暂停。将执行权释放，让其他线程有机会获取执行权。

### 20. 线程的匿名内部类

```java
public static void main(String[] args) {
    new Thread(new Runnable() {

        @Override
        public void run() {
            System.out.println("I was override.");
        }
    }) {

        @Override
        public void run() {
            System.out.println("I will execute.");
        }
    }.start();
}
```

简单源码

```java
public class Thread implements Runnable {

    public Thread(Runnable target) {

    }

    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }

}
```

