## 016-多线程

![JavaSE.png](https://raw.githubusercontent.com/JustDo23/SnailMonitor/master/Picture/Cover/JavaSE.png)

> 引言： Java Platform, Standard Edition.
>
> 作者：JustDo23
>
> 时间：2022年09月09日
>
> 官网：[https://www.oracle.com](https://www.oracle.com)

### 08. 生产者与消费者

1. **极简示例**

    ```java
    /**
     * 多线程：单个生产者与单个消费者示例
     *
     * @author JustDo23
     * @since 2022年09月09日
     */
    public class ProducerConsumer {
    
        public static void main(String[] args) {
            Resource resource = new Resource();
            Producer producer = new Producer(resource);
            Consumer consumer = new Consumer(resource);
            new Thread(producer).start();
            new Thread(consumer).start();
        }
    
    }
    
    class Resource {
    
        private String name; // 商品名称
        private int count;
    
        public synchronized void produce(String goods) {
            this.name = goods + "@" + count;
            this.count++;
            System.out.println("--生产者-- ：" + this.name);
        }
    
        public synchronized void consume() {
            System.out.println("--消费者-- ：" + this.name);
        }
    
    }
    
    class Producer implements Runnable {
    
        private Resource resource;
    
        public Producer(Resource resource) {
            this.resource = resource;
        }
    
        @Override
        public void run() {
            while (true) {
                resource.produce("面包");
            }
        }
    
    }
    
    class Consumer implements Runnable {
    
        private Resource resource;
    
        public Consumer(Resource resource) {
            this.resource = resource;
        }
    
        @Override
        public void run() {
            while (true) {
                resource.consume();
            }
        }
    
    }
    ```

2. **分析问题**

    * 在没有同步锁的情况下生产者和消费者被 CPU 随机执行，结果混乱。
    * 添加同步锁之后因为 CPU 随机执行导致一方可能刚释放锁就又获取了锁。

3. **代码升级**

    ```java
    class Resource {
    
        private String name;
        private int count;
        private boolean flag; // 标记
    
        public synchronized void produce(String goods) {
            if (flag) {
                try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); }
            }
            this.name = goods + "@" + count;
            this.count++;
            System.out.println("--生产者-- ：" + this.name);
            flag = true;
            this.notify();
        }
    
        public synchronized void consume() {
            if (!flag) {
                try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); }
            }
            System.out.println("--消费者-- ：" + this.name);
            flag = false;
            this.notify();
        }
    
    }
    ```

4. **简单说明**

    * 新增标记位以表示当前是否需要生产或者消费。
    * 一方发现无需操作时先进入等待状态，释放同步锁；一方操作完成后修改标记位，唤醒另一方。

### 09. 等待唤醒机制

1. **简单介绍**

    `等待/唤醒机制` 是可以改变线程状态从而对线程运行进行控制的方式。

2. **重点方法**

    **`wait()`**：会让线程处于等待状态，其实就是将线程临时存储到了线程池中。
    
    **`notify()`**：会唤醒线程池中任意一个等待的线程。
    
    **`notifyAll()`**：会唤醒线程池总所有的等地线程。
    
    **注意**：这些方法必须使用在同步中，因为必须要标识出方法所属的同步锁。另外 `当前线程必须拥有此对象监视器` 也就是说多个线程在使用同一个 `同步锁` 而后相互之间才能进行 `等待/唤醒` 操作。
    
    **解惑**：为什么这些方法都是定义在 **`Object`** 类当中呢？因为，这些方法必须标识所属的锁，而锁可以是任意对象，而任意对象都可以调用的方法必然是在 **`Object`** 类当中的方法。

### 10. 多生产者与多消费者

1. **问题一**

    **`问题`**：生产的商品没有被消费；同一个商品被消费多次。

    **`分析`**：被唤醒的线程没有判断标记直接向下执行。

    **`解决`**：被唤醒的线程必须再次判断标记。

    **`方法`**：将单次的 `if` 判断方式修改为多次的 `while` 判断方式。

2. **问题二**

    **`问题`**：修改为 `while` 判断之后，出现了 `死锁` 现象。

    **`分析`**：生产方随机唤醒了线程池中的生产者线程；也就是本方唤醒了本方。

    **`解决`**：希望本方唤醒的是对方线程。

    **`方法`**：将单个随机的 `notify` 唤醒方式修改为唤醒所有的 `notifyAll` 方式。

    **`注意`**：如果再添加多个同步锁来使用同步嵌套的方法，极有可能出现 `死锁` 现象。

3. **遗憾**

    使用唤醒所有的方式，效率偏低。以下方式可解决效率问题。

### 11. 接口 Lock

1. **简单介绍**

    在 `JDK 1.5` 包路径 `java.util.concurrent.locks` 下提供了一个更加面向对象的 `Lock` 锁，提供了比使用 `synchronized` 方法和语句可获得的更广泛的锁定操作。简单来说就是 `synchronized` 是隐式锁，而 `Lock` 提供了更多的显示的锁操作。

2. **重点方法**

    **`lock()`**：获取锁。
    
    **`unlock()`**：释放锁。
    
    **`newCondition()`**：返回绑定到此 Lock 实例的新 Condition 实例。
    
3. **更多责任**

    随着灵活性的增加，也带来了更多的责任。必须注意锁的释放。

    ```java
    public void release() {
        Lock lock = new ReentrantLock(); // 实例化
        lock.lock(); // 获取锁
        try {
            // 执行任务
        } finally {
            lock.unlock(); // 释放锁
        }
    }
    ```

### 12. 接口 Condition

1. **简单介绍**

   接口 `Lock` 可以支持多个相关的 `Condition` 对象。而 `Condition` 将 `Object` 监视器方法 `wait` `notify` 和 `notifyAll` 分解成截然不同的对象，以便通过将这些对象与任意 `Lock` 实现组合使用。
   也就是说，`Lock` 替代了 `synchronized` 方法和语句的使用，`Condition` 替代了 `Object` 监视器方法的使用。

2. **重点方法**

    **`await()`**：造成当前线程在接到信号或被中断之前一直处于等待状态。
    
    **`signal()`**：随机唤醒一个等待线程。
    
    **`signalAll()`**：唤醒所有等待线程。
    
3. **获取方式**

    使用 Lock 实例的 `newCondition()` 方法获取。

### 13. 官方范例

```java
class BoundedBuffer {

    final Lock lock = new ReentrantLock();
    final Condition notFull = lock.newCondition();
    final Condition notEmpty = lock.newCondition();

    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```

